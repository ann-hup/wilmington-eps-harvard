function [schedule, W, bestFaceIDs] = addWellsAndSimulationSchedule(mainDir,G, bc, rock)
%ADDWELLSANDSIMULATIONSCHEDULE Adds wells to W struct and builds a schedule
%for the solver to use in the simulation
    % - Reads in the data containing the superwell ID, corresponding cell ID
    % for perforation, and a flag for whether that superwell is an injector
    % (1) or producer (-1). This data is generated by calling the main
    % method function algorithmForWells(mainDir, G).
    % - Creates a timestep array 
    % - Builds well structure W for simulation
    % - Builds schedule for solver. For each well, the corresponding fluid
    % - rate at each time step is loaded into the schedule
%  ARGUMENTS
    % mainDir - general directory 
    % G - meshed reservoir surface via finite element method
    % bc - boundary conditions
    % rock - unit rock structure, including its porosity/permeability
    % properties
%  RETURNS
    % schedule - schedule for simulation to use
    % W - well structure with all wells added and relevant properties
    % bestFaceIDs = list of faceIDs, with each superwell identifying one

    bestFaceIDs = [];
 
    % RUN IF ORIGINAL DATA BEING INPUTTED TO THE MODEL CHANGES
   %[superwellMatrix, nearestCellMatrixOutput, bestFaceIDs] = algorithmForWells(mainDir, G);
    
   [schedule, W] = TwoPhaseADWells(mainDir, G, bc, rock);
   
%     % import the data generated from algorithmForWells function above
%     well_cell_data = dlmread(strcat(mainDir, 'superwellData/well_cell_mapping.dat'));  
%     well_fluid_rate_data = dlmread(strcat(mainDir, 'superwellData/superwell_fluid_rates.dat')); 
%     
%     % import timestep data
%     timestep_info = dlmread(strcat(mainDir, 'dataExported/Injection/date.dat'));  
%     dt = diff(timestep_info);
%     dt = dt * 3.154e7;
%     %dt = dt(408:1008);
%     
%     W = [];
%     
%     % Add wells to W struct
%     inject_i = 1; produce_i = 1;
%     for entry = 1 : size(well_cell_data, 1)
%         if well_cell_data(entry, 3) == 1
%             W = addWell(W, G, rock, well_cell_data(entry, 2), 'type','rate', 'val', ...
%                 well_fluid_rate_data(1, entry), 'Comp_i', [1 0], 'Sign', 1, 'refDepth', []); % [0, 1]
%             inject_i = inject_i + 1;
%         else
%             W = addWell(W, G, rock, well_cell_data(entry, 2), 'type','rate', 'val', ...
%                 well_fluid_rate_data(1, entry) * -1, 'Comp_i', [1 0], 'Sign', -1, 'refDepth', []);
%             produce_i = produce_i + 1;
%         end
%     end 
%    
%     % injector and producer graphs data
%     % [overall_figs, figs_part1, figs_part2, overlay_figs, indiv_well_rates] = ...
%     % createPlots(well_cell_data, well_fluid_rate_data, timestep_info, 1:10);
%     
% 
%     % build scheduler 
%     schedule = [];
%     factorWI = 0.2;
%      
%     schedule = simpleSchedule(dt,'W',W, 'bc', bc);
%     schedule.step.control=[1:length(dt)]';
%     
%     scheduleJS = [];
%     
%     tmp = cell(length(dt), 1); 
%     scheduleJS = struct('step', schedule.step);
%     scheduleJS.control = struct('W', tmp, 'bc', tmp, 'src', tmp);
%     
%     for wellID = 1:length(W)
%         for k = 1:length(dt)
%             scheduleJS.control(k).W(wellID) = W(wellID);        
%             if W(wellID).sign == 1
%                 scheduleJS.control(k).W(wellID).val = well_fluid_rate_data(k, wellID);
%             else
%                 scheduleJS.control(k).W(wellID).val = -1 * well_fluid_rate_data(k, wellID);
%             end
%             
%             % scheduleJS.control(k).W.lims.bhp = 40e6;
%             % scheduleJS.control(k).W.WI = scheduleJS.control(k).W.WI*factorWI;
%         end
%     end
%   
%   schedule = scheduleJS;
end

function [superwellMatrix, nearestCellMatrixOutput, bestFaceIDs] = algorithmForWells(mainDir, G)
%ALGORITHMFORWELLS Equivalent of a main method that calls all necessary
%helper functions to run the algorithms that produce two .dat files: one
%with a list of superwells, corresponding optimal cellIDs for perforation,
%and injector/producer flag, and a list of fluid injection or production
%rates at each time step for each superwell.
    % - Reads in coordinate data for original wells and their
    % injection/production rates
    % - Generates the superwell matrix by grouping every possible well into
    % the cell it belongs to, based on the stratification grid that is
    % devised by bounds for x and y and a chosen dx and dy
    % - Finds the closest outer face (projection onto xy plane at the top
    % of the reservoir essentially) for each superwell
    % - Find the closest cell to each superwell

    % Read in coordinate data for injectors and producers lat, long
    % (1976-2020 data)
    % injectionWellsFile = dlmread(strcat(mainDir, 'dataExported/Injection/coord.dat'));  
    % productionWellsFile = dlmread(strcat(mainDir, 'dataExported/Production/coord.dat'));  
    % x_I = injectionWellsFile(:, 2); y_I = injectionWellsFile(:, 1);
    
    % Read in injection/production rates (1976-2020 data)
    % injectionRatesFile = dlmread(strcat(mainDir, 'dataExported/Injection/waterInjection.dat'));  
    % productionRatesFile = dlmread(strcat(mainDir, 'dataExported/Production/waterProduction.dat'));
    
    % Read in coordinate data and injection/production rates long, lat
    % (1936-2020 data)
    newCoordsI = dlmread(strcat(mainDir, 'Exported/Injection/coord.dat'));
    newCoordsP = dlmread(strcat(mainDir, 'Exported/Production/coord.dat'));
    length(intersect(newCoordsI, newCoordsP));
    newRatesI = dlmread(strcat(mainDir, 'Exported/Injection/waterInjection.dat'));
    newRatesP = dlmread(strcat(mainDir, 'Exported/Production/waterProduction.dat'));
    x_I = newCoordsI(:, 1); y_I = newCoordsI(:, 2);
    x_P = newCoordsP(:, 1); y_P = newCoordsP(:, 2);
    
    % Generate superwell matrix
    %[wilmingtonWellIDs,upperExteriorFaceIDs, upperExteriorFaceCentroids, superwellMatrix] = ...
    %    generateSuperwellMatrix(mainDir, G, x_I, y_I, injectionRatesFile, productionRatesFile);
    
    [wilmingtonWellIDs,upperExteriorFaceIDs, upperExteriorFaceCentroids, superwellMatrix] = ...
        generateSuperwellMatrix(mainDir, G, x_I, y_I, x_P, y_P, newRatesI, newRatesP);
    
    % Find closest face on upper exterior boundary of rock to each superwell
    [superwellMatrix, bestFaceIDs] = findClosestOuterFace(superwellMatrix, upperExteriorFaceCentroids, ...
        upperExteriorFaceIDs);
    
    % Find closest cell to each superwell, and has the side effect of 
    % writing data to the two .dat files 
    nearestCellMatrixOutput = findClosestReservoirCell(mainDir, G, superwellMatrix);
end